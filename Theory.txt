
1) What is the purpose of threading in C#?

To increase the responsiveness and the throughput of an application.

2) What is the difference between thread and process?

Processes are the different applications that run in parallel on a computer. 
Threads are the basic unit to which the OS allocates processor time.
Threads also run in parallel but within a single process and they also share heap memory. 
Processes are fully isolated from each other.

3) What is the difference between thread, thread pool and TPL? What is the preferred way to write multithreaded and parallel code?

A thread is the basic unit of execution that is allocated processor time by the operating system (thread scheduler).
The Thread class in .Net gives the programmer the most flexibility to create, manage and destroy threads but that comes with the overhead of time and memory.
Thread pools are a collection of threads that are shared and recycled but thread pools can create only background worker threads. 
Thread pools also limit the number of threads that can run simultaneously.
TPL (Task Parallel Library) is based on the concept of Tasks, which represent an asynchroneous operation. Tasks resemble threads or thread pool worker items

4) Describe a flow how exceptions are handled in threads?

Exception handling is done per thread, meaning that in the main thread we cannot catch exceptions from worker threads. 
Exception handling should be done in the worker thread instead. That is because every thread has it`s own execution path and call stack.
An unhandled exception in either foreground or background threads results in termination of the application.

5) What is the difference between foreground and background threads?

A managed thread is either a background thread or a foreground thread. 
Background threads are identical to foreground threads with one exception: a background thread does not keep the managed execution environment running. 
Once all foreground threads have been stopped in a managed process (where the .exe file is a managed assembly), the system stops all background threads and shuts down.
Threads that belong to the managed thread pool (that is, threads whose IsThreadPoolThread property is true) are background threads. 
All threads that enter the managed execution environment from unmanaged code are marked as background threads. 
All threads generated by creating and starting a new Thread object are by default foreground threads.

6) What is the difference between managed and unmanaged threads?

Managed threads are those created by the CLR and unmanaged threads - those created outside the runtime that enter the managed environment to execute code. 
The runtime monitors all the threads in its process that have ever executed code within the managed execution environment. It does not track any other threads. 

7) What is spinning and how is it different from Blocking?

When a thread attempts to acquire a lock but finds it busy, it must choose between spinning, 
which means repeatedly attempting to acquire the lock in the hope that it will become free, 
and blocking, which means suspending its execution and relinquishing its processor to some other thread. 
The choice between spinning and blocking involves balancing the processor time lost to spinning 
against the processor time required to save the context of a process when it blocks (context switch overhead).

8) What is Mutex? How is it different from other synchronization primitives?

Mutex is a synchronization primitive which grants exclusive access to a shared resource.
Mutex has thread affinity and a thread that has acquired the mutex must release it.
Unlike other primitives Mutex can be used for inter-process synchronization.
Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes. A local mutex exists only within your process.
Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.

9) What ways /options to avoid deadlocks and race conditions and other threading issues do you know ?

- Synchronized code regions. We can use the Monitor class or compiler support for this class to synchronize only the code block that needs it, improving performance.
- Manual synchronization. We can use the synchronization objects provided by the .NET class library (Synchronization Primitives) .
- Collection classes in the System.Collections.Concurrent namespace. These classes provide built-in synchronized add and remove operations. 
- Using Interlocked class methods.
- For deadlocks we can use method oveloads with time-out parameters like Monitor.TryEnter(Object object, Timespan timeout) 

10) What is the difference between lock and monitor?

Both are lcoking mechanisms. Lock keyword uses the Monitor class but provides a safe way to release the lock.
On the other hand with Monitor we should always make sure to release the lock manually by providing Monitor.Exit in finally block.

11) How to write thread safe code?

By manipulating shared data resources in a manner that guarantees the safe execution of a piece of code by the multiple threads at the same time.

12) Name potential pitfalls in Task Parallelism?

- introduces complexity
- parallel doesn`t always mean faster
- deadlocks and race conditions
- synchronization can hurt performance
- parallelization is limited by the hardware
- can lead to data corruption

13) What is the difference between attached and detached Child Tasks?

A detached child task is a task that executes independently of its parent.
		Category 	                                 Detached child tasks 	Attached child tasks

Parent waits for child tasks to complete. 	               No 	                Yes
Parent propagates exceptions thrown by child tasks. 	   No 	                Yes
Status of parent depends on status of child. 			   No 					Yes